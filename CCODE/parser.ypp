%{

#include <iostream>
#include "semantic.hpp"
#include <vector>
#include <map>
#define YYDEBUG 1

extern int yylex();
extern int lineNum;
extern char* yytext;
void yyerror(const char *s)
{
<<<<<<< HEAD
    std::cout << s << "Line: " << lineNum << std::endl;
=======
    //std::cout << s << "Line: " << lineNum << std::endl;
>>>>>>> 58c8080627ad54ad116b0d5fcd0fb4d71ebe44b5
}

//std::map<std::string,


int loop_activ=0;
int swith_active=0;



%}


%union{
    std::string *s;
    AllDeclaration* A;
    std::vector<AllDeclaration*> *v;
    int i;
    float f;
    std::vector<char> *c;
    std::vector<std::string*> *S;

}
<<<<<<< HEAD
%token <s> STRING_LITERAL IDENTIFIER LIBRARY
%token <i> I_CONSTANT
%token <f> F_CONSTANT
=======
%token <s> STRING_LITERAL IDENTIFIER LIBRARY 
%token <i> I_CONSTANT 
%token <f> F_CONSTANT 
>>>>>>> 58c8080627ad54ad116b0d5fcd0fb4d71ebe44b5

%token	TYPEDEF_NAME ENUMERATION_CONSTANT SIZEOF
%token RIGHT_ASSIGN LEFT_ASSIGN ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN
%token DIV_ASSIGN MOD_ASSIGN AND_ASSIGN XOR_ASSIGN OR_ASSIGN RIGHT_OP LEFT_OP INC_OP
%token DEC_OP PTR_OP AND_OP OR_OP LE_OP GE_OP EQ_OP NE_OP

%token	TYPEDEF EXTERN STATIC AUTO REGISTER
%token	CONST RESTRICT VOLATILE
%token	CHAR SHORT INT LONG SIGNED UNSIGNED FLOAT DOUBLE VOID

%token	STRUCT UNION ENUM ELLIPSIS

%token	CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN



%token INCLUDE 


%type <c> pointer
%type <A> include_row external_declaration function_definition declaration declaration_specifiers statement for_declaration
%type <A> init_declarator value cast_expression unary_expression postfix_expression block_item for_expression
%type <A> jump_statement expression_statement iteration_statement selection_statement labeled_statement compound_statement
%type <A> expression assigment primary_expression declarator direct_declarator function_name
%type <v> other_declaration arguments init_declarator_list block_item_list argument_expression_list
%type <s> type_qualifier type_specifier  assigment_operator unary_operator



%start begin



%right ELSE "then"
%left ','
%right '=' "+=" "-=" "*=" "/=" "%=" "<<=" ">>=" "&=" "^=" "|="
%right '?' ':'
%left OR_OP
%left AND_OP
%left '|'
%left '^'
%left '&'
%left EQ_OP NE_OP
%left '<' LE_OP '>' GE_OP
%left RIGHT_OP LEFT_OP
%left '+' '-'
%left '*' '/' '%'










%%

begin
    : {lineNum=1;}include_declaration {std::cout << "\n---------------\n" << "idemoooooooooo" << std::endl;}
    ;
    
include_declaration
    : include_row include_declaration 
    | other_declaration             {for (unsigned i=0; i<$1->size(); i++){
                                        (*$1)[i]->ispis();
                                        }
                                    }
    | error {std::cout << "greska u liniji " << lineNum << " token " << yytext << " nije ocekivan" << std::endl; yyclearin; yyerrok;} include_declaration
    ;

include_row
    : '#' INCLUDE STRING_LITERAL                    {$$ = new Include_declaration('"',*$3); $$->ispis();}
    | '#' INCLUDE LIBRARY                           {$$ = new Include_declaration('<',*$3); $$->ispis();}
    ;
     
    
other_declaration
    : external_declaration                          {
                                                        $$= new std::vector<AllDeclaration*>();
                                                        $$->push_back($1);
                                                    }
    | other_declaration external_declaration        {
                                                        $$=$1;
                                                        $$->push_back($2);
                                                    }
    ;

external_declaration
    : function_definition                           {$$=$1;}
    | declaration                                   {$$=$1;}
//    | error {std::cout << "greska u liniji " << lineNum << " token " << yytext << " nije ocekivan." << "ocekivan je: \n\n" << yystate << std::endl; yyclearin; yyerrok;}
    ;
	


function_definition
    : declaration_specifiers function_name '(' arguments ')' compound_statement         {
                                                                                            $$ = new Function_declaration(new Function_variable($1,$2),*$4, $6);
                                                                                        }
    | declaration_specifiers function_name '('')' compound_statement                    { 
                                                $$ = new Function_declaration(new Function_variable($1,$2),std::vector<AllDeclaration*>(),$5);
                                                }
    ;

function_name
    : IDENTIFIER                                {$$= new Function_name(*$1,0);}
    | pointer IDENTIFIER                        {$$= new Function_name(*$2,$1->size());}
    ;
    
arguments
    : arguments ','  declaration_specifiers declarator          {
                                                                    $$=$1;
                                                                    $$->push_back(new Variable($3,$4));
                                                                }
    | declaration_specifiers declarator                         {
                                                                    $$ = new std::vector<AllDeclaration*>();
                                                                    $$-> push_back(new Variable($1,$2));
                                                                }
    ;                                                           //TODO niz?
    
declaration_specifiers
    : type_specifier                        {$$ = new Declaration_specifiers(*$1);}
    | type_qualifier type_specifier         {$$ = new Declaration_specifiers(*$2,*$1);}
    ;
    

	
type_qualifier
    : CONST            {$$ = new std::string("const");}
    ;
    

type_specifier
    : VOID                  {$$ = new std::string("void");}
    | CHAR                  {$$ = new std::string("char");}
    | SHORT                 {$$ = new std::string("short");}
    | INT                   {$$ = new std::string("int");}
    | LONG                  {$$ = new std::string("long");}
    | FLOAT                 {$$ = new std::string("float");}
    | DOUBLE                {$$ = new std::string("double");}
    | SIGNED                {$$ = new std::string("signed");}
    | UNSIGNED              {$$ = new std::string("unsigned");}
    ;                       //TODO enum, struktura, unija
    
declarator
	: pointer direct_declarator   {$$ = new Declarator($2,$1->size());}
	| direct_declarator           {$$ = new Declarator($1,0);}
	;
	
direct_declarator
	: IDENTIFIER                               {$$ = new Id(*$1);}
	| IDENTIFIER '[' ']'                       {$$ = new Array(*$1);}
	;
	
pointer
	: '*' pointer          {
                                    $$=$2;
                                    $$->push_back('*');
                               }                
	| '*'                  {
                                    $$ = new std::vector<char>();
                                    $$-> push_back('*');
                               }
	;
	

    
declaration
    : declaration_specifiers init_declarator_list ';'       {$$ = new Declaration($1,*$2);}
    ;
    
init_declarator_list
    : init_declarator                                       {
                                                                $$= new std::vector<AllDeclaration*>();
                                                                $$->push_back($1);
                                                            }
    | init_declarator_list ',' init_declarator              {
                                                                $$=$1;
                                                                $$->push_back($3);
                                                            }
    ;

init_declarator
    : declarator '=' value                                  {$$=new Init_declarator($1,$3);}
    | declarator                                            {$$=new Init_declarator($1,nullptr);}
    ;
    
    
compound_statement
    : '{' block_item_list '}'                               {$$ = new Block_item_list(*$2);}
    | '{' '}'                                               {$$ = new Block_item_list();}
    ;
    
block_item_list
    : block_item                                            {
                                                                $$= new std::vector<AllDeclaration*>();
                                                                $$->push_back($1);
                                                            }
    | block_item_list block_item                            {
                                                                $$=$1;
                                                                $$->push_back($2);
                                                            }
    ;
    
block_item
    : declaration                                           {$$ = $1;}
    | statement                                             {$$ = $1;}
    ;

statement
    : expression_statement
    | labeled_statement
    | compound_statement
    | selection_statement
    | iteration_statement
    | jump_statement
    | error {std::cout << "greska u liniji " << lineNum << " token " << yytext << " nije ocekivan\n\n" << std::endl; yyclearin; yyerrok;}
    ;
	
labeled_statement
    : CASE value ':' statement                         {$$ = new Case($2, $4);}
    | DEFAULT ':' statement                            {$$ = new Default($3);}
    ;
	
selection_statement
    : IF '(' value ')' statement ELSE statement                {$$ = new If_else($3,$5,$7);}
    | IF '(' value ')' statement               %prec "then"    {$$ = new If_statement($3,$5);}
    | SWITCH '(' value ')' statement                           {$$ = new Switch($3,$5);}
    ;
	
iteration_statement
    : WHILE '(' value ')' statement                                      {$$ = new While($3,$5);}
    | DO statement WHILE '(' value ')' ';'                               {$$ = new Do_while($2,$5);}
    | FOR '(' for_expression for_expression ')' statement                {$$ = new For_statement_2($3,$4,$6);}
    | FOR '(' for_expression for_expression value ')' statement          {$$ = new For_statement_3($3,$4,$5,$7);}
    | FOR '(' for_declaration for_expression ')' statement                   {$$ = new For_statement_2($3,$4,$6);}
    | FOR '(' for_declaration for_expression value ')' statement             {$$ = new For_statement_3($3,$4,$5,$7);}
    ;
	
for_expression
    : ';'                                                           {$$ = new For_expression(nullptr);}
    | expression ';'                                                {$$ = new For_expression($1);}
    ;
    
for_declaration
    : declaration_specifiers init_declarator_list ';'       {$$ = new For_declaration($1,*$2);}
    ;
	
jump_statement
    : CONTINUE ';'                                                             {$$ = new Continue();}
    | BREAK ';'                                                                {$$ = new Break();}
    | RETURN ';'                                                               {$$ = new Return(nullptr);}
    | RETURN value ';'                                                         {$$ = new Return($2);}
    ;
    
expression_statement
    : ';'                                                                          {$$ = new Expression(nullptr);}
    | expression ';'                                                               {$$ = new Expression($1);}
    ;
    

    
expression
    : expression ',' assigment                                                     {$$ = new Comma($1,$3);}
    | assigment
    ;
assigment
    : value
    | IDENTIFIER assigment_operator value                                          {$$ = new Assigment(*$1,*$2,$3);}
    ;
    
assigment_operator
    : '='               {$$ = new std::string("=");}
    | ADD_ASSIGN        {$$ = new std::string("+=");}
    | SUB_ASSIGN        {$$ = new std::string("-=");}
    | MUL_ASSIGN        {$$ = new std::string("*=");}
    | DIV_ASSIGN        {$$ = new std::string("/=");}
    | MOD_ASSIGN        {$$ = new std::string("%=");}
    | LEFT_ASSIGN       {$$ = new std::string("<<=");}
    | RIGHT_ASSIGN      {$$ = new std::string(">>=");}
    | AND_ASSIGN        {$$ = new std::string("&=");}
    | XOR_ASSIGN        {$$ = new std::string("^=");}
    | OR_ASSIGN         {$$ = new std::string("|=");}
    ;
    
value
    : value '?' value ':' value                         {$$ = new Ternary_conditional($1,$3,$5);}
    | value OR_OP value                                  {$$ = new Logical_OR($1,$3);}
    | value AND_OP value                                  {$$ = new Logical_AND($1,$3);}
    | value '|' value                                   {$$ = new Bitwise_OR($1,$3);}
    | value '^' value                                   {$$ = new Bitwise_XOR($1,$3);}
    | value '&' value                                   {$$ = new Bitwise_AND($1,$3);}
    | value NE_OP value                                  {$$ = new Not_equal($1,$3);}
    | value EQ_OP value                                  {$$ = new Equal($1,$3);}
    | value '<' value                                   {$$ = new Less($1,$3);}
    | value '>' value                                   {$$ = new Greater($1,$3);}
    | value LE_OP value                                  {$$ = new Less_or_equal($1,$3);}
    | value GE_OP value                                  {$$ = new Greater_or_equal($1,$3);}
    | value RIGHT_OP value                              {$$ = new Bitwise_right_shift($1,$3);}
    | value LEFT_OP value                               {$$ = new Bitwise_left_shift($1,$3);}
    | value '+' value                                   {$$ = new Addition($1,$3);}
    | value '-' value                                   {$$ = new Subtraction($1,$3);}
    | value '*' value                                   {$$ = new Multiplication($1,$3);}
    | value '/' value                                   {$$ = new Division($1,$3);}
    | value '%' value                                   {$$ = new Remainder($1,$3);}
    | cast_expression
    ;
cast_expression
    : '(' type_specifier ')' cast_expression            {$$ = new Cast_expression(*$2,$4);}
    | unary_expression    
    ;               
    
unary_expression
    : postfix_expression
    | DEC_OP IDENTIFIER                             {$$ = new Prefix_decrement(*$2);}
    | INC_OP IDENTIFIER                             {$$ = new Prefix_increment(*$2);}
    | unary_operator unary_expression             {$$ = new Unary_operator(*$1,$2);}
    | SIZEOF unary_expression                     {$$ = new Sizeof($2);}
    | SIZEOF '(' type_specifier ')'               {$$ = new Sizeof_type(*$3);}
    ;
    
postfix_expression
    : primary_expression 
    | IDENTIFIER '[' expression ']'                     {$$ = new Array_subscripting(*$1,$3);}
    | IDENTIFIER '(' ')'                                {$$ = new Function_caller(*$1);}
    | IDENTIFIER '(' argument_expression_list  ')'      {$$ = new Function_caller(*$1,*$3);}
    | IDENTIFIER INC_OP                                 {$$ = new Postfix_decrement(*$1);}
    | IDENTIFIER DEC_OP                                 {$$ = new Postfix_decrement(*$1);}
    | IDENTIFIER '.' IDENTIFIER                         {$$ = new Union_access(*$1,*$3);}
    | IDENTIFIER PTR_OP IDENTIFIER                      {$$ = new Pointer_access(*$1,*$3);}
    ;                           // TODO pokazivaci
    
argument_expression_list
    : assigment                                         {
                                                            $$= new std::vector<AllDeclaration*>();
                                                            $$->push_back($1);
                                                        }
    | argument_expression_list ',' assigment            {
                                                            $$=$1;
                                                            $$->push_back($3);
                                                        }
    ;
    
primary_expression
    : IDENTIFIER                                        {$$ = new Id(*$1);}
    | I_CONSTANT                                        {$$ = new Integer($1);}
    | F_CONSTANT                                        {$$ = new Float($1);}
    | STRING_LITERAL                                    {$$ = new String_literal(*$1);}
    | '(' expression ')'                                {$$ = new Brackets($2);}
    ;

    

    
unary_operator
    : '&'       {$$ = new std::string("&");}
    | '*'       {$$ = new std::string("*");}
    | '+'       {$$ = new std::string("+");}
    | '-'       {$$ = new std::string("-");}
    | '~'       {$$ = new std::string("~");}
    | '!'       {$$ = new std::string("!");}
    ;

    
%%
extern FILE* yyin;

<<<<<<< HEAD
//int main(){
//        //yydebug=1;
//	yyin = fopen("1.c", "r");
//	yyparse();
//	return 0;
//}
=======
int main(){
        //yydebug=1;
	yyin = fopen("1.c", "r");
	yyparse();
	return 0;
}
>>>>>>> 58c8080627ad54ad116b0d5fcd0fb4d71ebe44b5
