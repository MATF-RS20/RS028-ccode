%{

#include <parsererror.h>
#include <codeeditor.h>
#include <iostream>
#include <set>
#define YYDEBUG 1

extern int yylex();
extern int lineNum;
extern char* yytext;

std::set<std::string> table;

ParserError pe;



void yyerror(const char *s)
{
    if(!isgraph(yytext[0])) {
        std::cout << s << "Line: " << lineNum << " kraj fajla nije ocekivan"<< std::endl;
    }else {
    std::cout << s << "Line: " << lineNum << " " << yytext << " nije ocekivan"<< std::endl;
    }


}



int loop_active;
int swith_active;



%}


%union{
    std::string *s;
    int i;
    float f;


}
%token <s> STRING_LITERAL IDENTIFIER LIBRARY
%token <i> I_CONSTANT
%token <f> F_CONSTANT

%token	TYPEDEF_NAME ENUMERATION_CONSTANT SIZEOF
%token RIGHT_ASSIGN LEFT_ASSIGN ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN
%token DIV_ASSIGN MOD_ASSIGN AND_ASSIGN XOR_ASSIGN OR_ASSIGN RIGHT_OP LEFT_OP INC_OP
%token DEC_OP PTR_OP AND_OP OR_OP LE_OP GE_OP EQ_OP NE_OP

%token	TYPEDEF EXTERN STATIC AUTO REGISTER
%token	CONST RESTRICT VOLATILE
%token	CHAR SHORT INT LONG SIGNED UNSIGNED FLOAT DOUBLE VOID

%token	STRUCT UNION ENUM ELLIPSIS

%token	CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN



%token INCLUDE END_OF_FILE

%type <s> type_specifier assigment_operator unary_operator function_name direct_declarator




%start begin



%right ELSE "then"
%left ','
%right '=' "+=" "-=" "*=" "/=" "%=" "<<=" ">>=" "&=" "^=" "|="
%right '?' ':'
%left OR_OP
%left AND_OP
%left '|'
%left '^'
%left '&'
%left EQ_OP NE_OP
%left '<' LE_OP '>' GE_OP
%left RIGHT_OP LEFT_OP
%left '+' '-'
%left '*' '/' '%'










%%

begin
    : {
        lineNum=1;
        CodeEditor::instance()->active()->words.clear();
        swith_active=0;
        loop_active=0;
      }include_declaration {
        pe.good("probably good syntax");
    }
    ;

include_declaration
    : include_row include_declaration
    | other_declaration
    ;

include_row
    : '#' INCLUDE STRING_LITERAL
    | '#' INCLUDE LIBRARY
    ;


other_declaration
    : external_declaration
    | other_declaration external_declaration
    ;

external_declaration
    : function_definition
    | declaration
    ;



function_definition
    : declaration_specifiers function_name '(' arguments ')' compound_statement {
                                                CodeEditor::instance()->active()->words.insert(*$2);
                                                table.insert(*$2);
                                             }

    | declaration_specifiers function_name '('')' compound_statement{
                                                CodeEditor::instance()->active()->words.insert(*$2);
                                                table.insert(*$2);
                                             }
    ;

function_name
    : IDENTIFIER
    | pointer IDENTIFIER {$$=$2;}
    ;

arguments
    : arguments ','  declaration_specifiers declarator
    | declaration_specifiers declarator
    ;

declaration_specifiers
    : type_specifier
    | type_qualifier type_specifier
    ;



type_qualifier
    : CONST
    ;


type_specifier
    : VOID                  {$$ = new std::string("void");}
    | CHAR                  {$$ = new std::string("char");}
    | SHORT                 {$$ = new std::string("short");}
    | INT                   {$$ = new std::string("int");}
    | LONG                  {$$ = new std::string("long");}
    | FLOAT                 {$$ = new std::string("float");}
    | DOUBLE                {$$ = new std::string("double");}
    | SIGNED                {$$ = new std::string("signed");}
    | UNSIGNED              {$$ = new std::string("unsigned");}
    ;

declarator
    : pointer direct_declarator

    | direct_declarator

    ;

direct_declarator
    : IDENTIFIER    {
        CodeEditor::instance()->active()->words.insert(*$1);
        table.insert(*$1);
        }
    | IDENTIFIER '[' ']' {
        CodeEditor::instance()->active()->words.insert(*$1);
        table.insert(*$1);
        }
    ;

pointer
    : '*' pointer
    | '*'
    ;



declaration
    : declaration_specifiers init_declarator_list ';'
    ;

init_declarator_list
    : init_declarator
    | init_declarator_list ',' init_declarator
    ;

init_declarator
    : declarator '=' value
    | declarator
    ;


compound_statement
    : '{' block_item_list '}'
    | '{' '}'
    ;

block_item_list
    : block_item
    | block_item_list block_item
    ;

block_item
    : declaration
    | statement
    ;

statement
    : expression_statement
    | labeled_statement
    | compound_statement
    | selection_statement
    | {loop_active++;} iteration_statement {loop_active--;}
    | jump_statement
    ;

labeled_statement
    : CASE {if (swith_active<=0){
                pe.add("case not in switch");
            }
           } value ':' statement
    | DEFAULT{if (swith_active<=0){
                pe.add("default not in switch");
                }
             } ':' statement
    ;

selection_statement
    : IF '(' value ')' statement ELSE statement
    | IF '(' value ')' statement               %prec "then"
    | SWITCH {swith_active++;}'(' value ')' statement {swith_active--;}
    ;

iteration_statement
    : WHILE '(' value ')' statement
    | DO  statement WHILE '(' value ')' ';'
    | FOR '(' for_expression for_expression ')' statement
    | FOR '(' for_expression for_expression value ')' statement
    | FOR  '(' for_declaration for_expression ')' statement
    | FOR '(' for_declaration for_expression value ')' statement
    ;

for_expression
    : ';'
    | expression ';'
    ;

for_declaration
    : declaration_specifiers init_declarator_list ';'
    ;

jump_statement
    : CONTINUE ';'{if (loop_active<=0){
                   pe.add("continue not in loop");
                   }
                }
    | BREAK ';'{if (loop_active<=0){
        pe.add("break not in loop");
        }
     }
    | RETURN ';'
    | RETURN value ';'
    ;

expression_statement
    : ';'
    | expression ';'
    ;



expression
    : expression ',' assigment
    | assigment
    ;
assigment
    : value
    | IDENTIFIER assigment_operator value {if(table.find(*$1)==table.end())
                                           pe.add("use of undeclared identifier " + *$1);
                                         }
    ;

assigment_operator
    : '='               {$$ = new std::string("=");}
    | ADD_ASSIGN        {$$ = new std::string("+=");}
    | SUB_ASSIGN        {$$ = new std::string("-=");}
    | MUL_ASSIGN        {$$ = new std::string("*=");}
    | DIV_ASSIGN        {$$ = new std::string("/=");}
    | MOD_ASSIGN        {$$ = new std::string("%=");}
    | LEFT_ASSIGN       {$$ = new std::string("<<=");}
    | RIGHT_ASSIGN      {$$ = new std::string(">>=");}
    | AND_ASSIGN        {$$ = new std::string("&=");}
    | XOR_ASSIGN        {$$ = new std::string("^=");}
    | OR_ASSIGN         {$$ = new std::string("|=");}
    ;

value
    : value '?' value ':' value
    | value OR_OP value
    | value AND_OP value
    | value '|' value
    | value '^' value
    | value '&' value
    | value NE_OP value
    | value EQ_OP value
    | value '<' value
    | value '>' value
    | value LE_OP value
    | value GE_OP value
    | value RIGHT_OP value
    | value LEFT_OP value
    | value '+' value
    | value '-' value
    | value '*' value
    | value '/' value
    | value '%' value
    | cast_expression
    ;
cast_expression
    : '(' type_specifier ')' cast_expression
    | unary_expression
    ;

unary_expression
    : postfix_expression
    | DEC_OP IDENTIFIER {if(table.find(*$2)==table.end())
                         pe.add("use of undeclared identifier " + *$2);
                       }
    | INC_OP IDENTIFIER {if(table.find(*$2)==table.end())
        pe.add("use of undeclared identifier " + *$2);
      }
    | unary_operator unary_expression
    | SIZEOF unary_expression
    | SIZEOF '(' type_specifier ')'
    ;

postfix_expression
    : primary_expression
    | IDENTIFIER '[' expression ']' {if(table.find(*$1)==table.end())
                                     pe.add("use of undeclared identifier " + *$1);
                                   }
    | IDENTIFIER '(' ')' {if(table.find(*$1)==table.end())
                          pe.add("use of undeclared identifier " + *$1);
                        }
    | IDENTIFIER '(' argument_expression_list  ')' {if(table.find(*$1)==table.end())
                                                    pe.add("use of undeclared identifier " + *$1);
                                                  }
    | IDENTIFIER INC_OP {if(table.find(*$1)==table.end())
                         pe.add("use of undeclared identifier " + *$1);
                       }
    | IDENTIFIER DEC_OP {if(table.find(*$1)==table.end())
                         pe.add("use of undeclared identifier " + *$1);
                       }
    | IDENTIFIER '.' IDENTIFIER {if(table.find(*$1)==table.end())
                                 pe.add("use of undeclared identifier " + *$1);
    if(table.find(*$3)==table.end())
                                     pe.add("use of undeclared identifier " + *$3);
                               }
    | IDENTIFIER PTR_OP IDENTIFIER {if(table.find(*$1)==table.end())
                                    pe.add("use of undeclared identifier " + *$1);
    if(table.find(*$3)==table.end())
                                     pe.add("use of undeclared identifier " + *$3);
                                  }
    ;                           // TODO pokazivaci

argument_expression_list
    : assigment
    | argument_expression_list ',' assigment
    ;

primary_expression
    : IDENTIFIER {if(table.find(*$1)==table.end())
                  pe.add("use of undeclared identifier " + *$1);
                }
    | I_CONSTANT
    | F_CONSTANT
    | STRING_LITERAL
    | '(' expression ')'
    ;




unary_operator
    : '&'       {$$ = new std::string("&");}
    | '*'       {$$ = new std::string("*");}
    | '+'       {$$ = new std::string("+");}
    | '-'       {$$ = new std::string("-");}
    | '~'       {$$ = new std::string("~");}
    | '!'       {$$ = new std::string("!");}
    ;


%%
